ORDER BY Queries

   Using indexes can help you improve the performance of queries with an
   ORDER BY clause. This includes ORDER BY clauses with either ascending
   or descending sorts, as well as more than one ordering field.

   To use the index for an ORDER BY, the index's key list order and sort
   order must match the orderings specified in the query. If the index’s
   keys also match filter conditions in the query, using the index also
   reduces the amount data read from the index.

Index Key List Order and Sort Order Examples

   The following table provides examples of when MapR-DB can and cannot
   use an index for ordering, based on the index key list ordering and
   sort ordering specified. Assume a table exists with a [1]composite
   index on fields, Address.State and FullName.LastName. You have defined
   both keys in ascending order. Assume the query has an ORDER BY on the
   fields Address.State and FullName.LastName, both in ascending order:
     Ordering in Query   Use of Index for Ordering
   Address.State:ASC

   Yes
   Address.State:DESC

   No

   Sort direction does not match.
Address.State:ASC,
FullName.LastName ASC

   Yes
   FullName.LastName:ASC

   No

   Address.State must be included as a prefix in the ordering.
FullName.LastName:ASC,
Address.State:ASC

   No

   Sort directions match, but the order of fields does not match.

Filtering and ORDER BY Query Examples

   The examples in this section assume that you have a [2]composite index
   defined with the following two indexed fields:
     * Address.State:ASC
     * FullName.LastName:ASC

   The following table shows examples for different filtering and ORDER BY
   scenarios using this composite index:
   Query Condition Ordering in Query Index Use
{"$eq":{"Address.State":"CA"}}

FullName.LastName:ASC

   Both filtering and ordering
{"$gt":{"Address.State":"CA"}}

Address.State:ASC

   Both filtering and ordering
{"$gt":{"Address.State":"CA"}}

Address.State:DESC

   Only filtering, because the sort direction does not match
{
  "$and":[
    {"$eq":{"Address.State":"CA"}},
    {"$ge":{"FullName.LastName":"Smith"}}
  ]
}

FullName.LastName:ASC

   Both filtering and ordering
{"$gt":{"Address.State":"CA"}}

Address.State:ASC,
FullName.LastName:ASC

   Both filtering and ordering
{"$gt":{"Address.State":"CA"}}

FullName.LastName:ASC

   Only filtering
{"$in":{"Address.State":["CA","TX"]}}

FullName.LastName:ASC

   Only filtering
{"$ge":{"FullName.LastName":"Smith"}}

Address.State:ASC,
FullName.LastName:ASC

   Only ordering, because FullName.LastName is not a prefix in the filter
   lookup

Partial Sorts with Non-Covering Indexes

   MapR-DB updates secondary indexes asynchronously, which can result in
   updates to the index lagging the parent JSON table. To avoid this
   behavior in your OJAI application, you can set a query option in your
   application. See [3]Avoiding Partial Sorts with Secondary Indexes in
   OJAI for details on how to do this. See [4]Asynchronous Secondary Index
   Updates for a more detailed discussion of asynchronous index updates.

   One consequence of this index update lag is the impact on queries that
   use [5]non-covering indexes to provide the ordering of a query. Because
   the index is not fully synchronized with its parent JSON data, data
   read through the index may be out-of-date.

   Here is an example that illustrates this behavior.
    1. Suppose you have a query with the following criteria:
          + Selects docField
          + Filter condition where docField >= 5
          + Order by on docField
    2. You have an index where docField is an indexed field. The index
       optimizes both the filter condition and order by. The query also
       selects other fields, so the index is a non-covering index for the
       query.
    3. When reading through the index, MapR-DB reads a document where
       docField's value is 9. The data for that field in the JSON table is
       also 9. The data is consistent.
    4. The next entry in the index has docField set to 10. This value is
       in the proper sort order relative to the previous value of 9. But,
       the data in the JSON table has changed from 10 to 6. The update is
       not yet reflected in the index.
    5. MapR-DB returns the value 6 (not 10), which is out of order,
       relative to data previously read from the index.

   The following table and diagram illustrate the difference in sort
   order, depending on the state of updates, for this example:
             Update State            Query Result in docField Sort Order
   Before update                     5, …, 9, 10
   JSON table updated, but not index 5, …, 9, 6
   Index updated                     5, 6, …, 9
   [PartialSorts.png]
   Note: This behavior does not occur with covering indexes. MapR-DB only
   reads from a single data source, the index, when using covering
   indexes.

References

   1. file://localhost/root/docsync/tmp/maprdocs.mapr.com/home/MapR-DB/Indexes/design-composite-index.html
   2. file://localhost/root/docsync/tmp/maprdocs.mapr.com/home/MapR-DB/Indexes/design-composite-index.html
   3. file://localhost/root/docsync/tmp/maprdocs.mapr.com/home/MapR-DB/JSON_DB/partialSortIndexesOJAI.html#reference_gs1_vxr_y1b
   4. file://localhost/root/docsync/tmp/maprdocs.mapr.com/home/MapR-DB/Indexes/indexes-consistency.html#indexes-consistency
   5. file://localhost/root/docsync/tmp/maprdocs.mapr.com/home/MapR-DB/Indexes/index-types-covering.html#concept_qdg_p5j_t1b
